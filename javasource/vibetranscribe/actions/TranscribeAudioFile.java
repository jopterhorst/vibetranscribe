// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package vibetranscribe.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserAction;
import org.vosk.LibVosk;
import org.vosk.LogLevel;
import org.vosk.Model;
import org.vosk.Recognizer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.mendix.logging.ILogNode;
import com.mendix.core.Core;

/**
 * https://github.com/jopterhorst/vibetranscribe
 */
public class TranscribeAudioFile extends UserAction<java.lang.String>
{
	/** @deprecated use AudioFile.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __AudioFile;
	private final system.proxies.FileDocument AudioFile;
	/** @deprecated use VoskModel.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __VoskModel;
	private final system.proxies.FileDocument VoskModel;

	public TranscribeAudioFile(
		IContext context,
		IMendixObject _audioFile,
		IMendixObject _voskModel
	)
	{
		super(context);
		this.__AudioFile = _audioFile;
		this.AudioFile = _audioFile == null ? null : system.proxies.FileDocument.initialize(getContext(), _audioFile);
		this.__VoskModel = _voskModel;
		this.VoskModel = _voskModel == null ? null : system.proxies.FileDocument.initialize(getContext(), _voskModel);
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		// BEGIN USER CODE
		long startTime = System.currentTimeMillis();
		logger.info("Starting Vosk transcription: " + (AudioFile != null ? AudioFile.getName() : "unknown file"));
		
		if (AudioFile == null || !AudioFile.getHasContents()) {
			logger.error("No audio file provided");
			throw new com.mendix.systemwideinterfaces.MendixRuntimeException("No audio file provided or file is empty");
		}

		if (VoskModel == null || !VoskModel.getHasContents()) {
			logger.error("No Vosk model provided");
			throw new com.mendix.systemwideinterfaces.MendixRuntimeException("No Vosk model provided or model file is empty");
		}

		String fileName = AudioFile.getName();
		
		// Validate audio format
		if (!isValidAudioFormat(fileName)) {
			logger.warn("Non-WAV format detected: " + fileName + " - Vosk works best with WAV files");
		}

		try {
			// Set Vosk log level
			LibVosk.setLogLevel(LogLevel.WARNINGS);
			
			// Extract and initialize Vosk model
			String modelPath = extractVoskModel();
			logger.info("Loading Vosk model from: " + modelPath);
			
			Model model = null;
			Recognizer recognizer = null;
			InputStream audioStream = null;
			ByteArrayOutputStream outputStream = null;
			
			try {
				model = new Model(modelPath);
				recognizer = new Recognizer(model, 16000);
				
				// Get the audio file content as byte array
				outputStream = new ByteArrayOutputStream();
				AudioFile.getContents(getContext(), outputStream);
				byte[] audioBytes = outputStream.toByteArray();
				
				// Analyze and convert audio if needed
				audioBytes = analyzeAndConvertAudio(audioBytes, fileName);
				
				// Create input stream and skip WAV header if present
				audioStream = new ByteArrayInputStream(audioBytes);
				if (audioBytes.length > 44 && isWavFile(audioBytes)) {
					audioStream.skip(44); // Skip WAV header
					logger.info("Skipped WAV header for processing");
				}
				
				// Process audio in chunks for Vosk
				byte[] buffer = new byte[4096];
				int bytesRead;
				StringBuilder transcriptionResult = new StringBuilder();
				ObjectMapper mapper = new ObjectMapper();
				
				while ((bytesRead = audioStream.read(buffer)) != -1) {
					// Validate bytesRead to ensure proper length parameter handling (CWE-130)
					if (bytesRead > 0) {
						if (recognizer.acceptWaveForm(buffer, bytesRead)) {
							String result = recognizer.getResult();
							JsonNode resultJson = mapper.readTree(result);
							String text = resultJson.get("text").asText();
							if (!text.trim().isEmpty()) {
								if (transcriptionResult.length() > 0) {
									transcriptionResult.append(" ");
								}
								transcriptionResult.append(text.trim());
								logger.debug("Partial result: " + text);
							}
						}
					}
				}
				
				// Get final result
				String finalResult = recognizer.getFinalResult();
				JsonNode finalJson = mapper.readTree(finalResult);
				String finalText = finalJson.get("text").asText();
				if (!finalText.trim().isEmpty()) {
					if (transcriptionResult.length() > 0) {
						transcriptionResult.append(" ");
					}
					transcriptionResult.append(finalText.trim());
				}
				
				// Calculate timing
				long endTime = System.currentTimeMillis();
				double transcriptionTimeSeconds = (endTime - startTime) / 1000.0;
				
				String finalTranscription = transcriptionResult.toString().trim();
				
				if (finalTranscription.isEmpty()) {
					logger.warn("No speech detected in audio file");
					logger.info("Vosk transcription completed in " + String.format("%.2f", transcriptionTimeSeconds) + " seconds");
					return "No speech detected in the audio file. Please ensure the audio contains clear speech and is in WAV format (16kHz, 16-bit, mono recommended).";
				}
				
				logger.info("Vosk transcription completed successfully in " + String.format("%.2f", transcriptionTimeSeconds) + " seconds");
				logger.info("Final result: '" + finalTranscription + "' (" + finalTranscription.length() + " chars)");
				
				return finalTranscription;
				
			} finally {
				// Clean up resources
				if (audioStream != null) {
					try { audioStream.close(); } catch (Exception e) { logger.warn("Failed to close audio stream: " + e.getMessage()); }
				}
				if (outputStream != null) {
					try { outputStream.close(); } catch (Exception e) { logger.warn("Failed to close output stream: " + e.getMessage()); }
				}
				if (recognizer != null) {
					try { recognizer.close(); } catch (Exception e) { logger.warn("Failed to close recognizer: " + e.getMessage()); }
				}
				if (model != null) {
					try { model.close(); } catch (Exception e) { logger.warn("Failed to close model: " + e.getMessage()); }
				}
				
				// Clean up temporary model directory (only if not cached)
				try {
					File tempModelDir = new File(modelPath).getParentFile();
					if (tempModelDir.getName().startsWith("vosk-model-")) {
						// Check if this model is cached - if so, don't delete it
						boolean isCached = false;
						for (String cachedPath : modelCache.values()) {
							if (cachedPath.equals(modelPath)) {
								isCached = true;
								break;
							}
						}
						
						if (!isCached) {
							deleteDirectory(tempModelDir);
							logger.info("Cleaned up temporary model directory: " + tempModelDir.getAbsolutePath());
						} else {
							logger.info("Model is cached, skipping cleanup: " + tempModelDir.getAbsolutePath());
						}
					}
				} catch (Exception cleanupEx) {
					logger.warn("Failed to cleanup temporary model directory: " + cleanupEx.getMessage());
				}
			}
			
		} catch (Exception e) {
			logger.error("Vosk transcription failed: " + e.getMessage(), e);
			throw new com.mendix.systemwideinterfaces.MendixRuntimeException(
				"Error during Vosk audio transcription: " + e.getMessage() + 
				". Please ensure the audio file is in a supported format and the Vosk model is properly uploaded and valid.", e);
		}
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "TranscribeAudioFile";
	}

	// BEGIN EXTRA CODE
	private static final ILogNode logger = Core.getLogger("VibeTranscribe");
	
	// Model cache - maps model hash to extracted directory path
	private static final ConcurrentHashMap<String, String> modelCache = new ConcurrentHashMap<>();
	
	// Cache cleanup tracking
	private static final ConcurrentHashMap<String, Long> cacheAccessTime = new ConcurrentHashMap<>();
	private static final long CACHE_CLEANUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
	private static final long CACHE_MAX_AGE = 7 * 24 * 60 * 60 * 1000; // 7 days
	
	/**
	 * Extract and prepare the Vosk model from the uploaded ZIP file with caching
	 */
	private String extractVoskModel() throws Exception {
		// Calculate hash of the model content for caching
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		VoskModel.getContents(getContext(), outputStream);
		byte[] zipBytes = outputStream.toByteArray();
		outputStream.close();
		
		String modelHash = calculateModelHash(zipBytes);
		logger.info("Model hash: " + modelHash);
		
		// Check if model is already cached and directory exists
		String cachedPath = modelCache.get(modelHash);
		if (cachedPath != null && new File(cachedPath).exists() && isVoskModelDirectory(new File(cachedPath))) {
			// Update access time
			cacheAccessTime.put(modelHash, System.currentTimeMillis());
			logger.info("Using cached Vosk model: " + cachedPath);
			return cachedPath;
		} else if (cachedPath != null) {
			// Cached path exists but directory is gone - remove from cache
			modelCache.remove(modelHash);
			cacheAccessTime.remove(modelHash);
			logger.warn("Cached model directory no longer exists, will re-extract: " + cachedPath);
		}
		
		// Clean up old cache entries periodically
		cleanupOldCacheEntries();
		
		// Extract the model
		String extractedPath = extractModelToFileSystem(zipBytes, modelHash);
		
		// Cache the result
		modelCache.put(modelHash, extractedPath);
		cacheAccessTime.put(modelHash, System.currentTimeMillis());
		
		logger.info("Successfully extracted and cached Vosk model: " + extractedPath);
		return extractedPath;
	}
	
	/**
	 * Calculate SHA-256 hash of model content for caching
	 */
	private String calculateModelHash(byte[] zipBytes) throws Exception {
		MessageDigest digest = MessageDigest.getInstance("SHA-256");
		byte[] hash = digest.digest(zipBytes);
		StringBuilder hexString = new StringBuilder();
		for (byte b : hash) {
			String hex = Integer.toHexString(0xff & b);
			if (hex.length() == 1) {
				hexString.append('0');
			}
			hexString.append(hex);
		}
		return hexString.toString().substring(0, 16); // Use first 16 chars for shorter paths
	}
	
	/**
	 * Extract model to file system with unique directory name
	 */
	private String extractModelToFileSystem(byte[] zipBytes, String modelHash) throws Exception {
		// Create a directory name based on hash for consistency
		String tempDir = System.getProperty("java.io.tmpdir");
		String modelDirName = "vosk-model-" + modelHash;
		Path modelPath = Paths.get(tempDir, modelDirName);
		
		try {
			Files.createDirectories(modelPath);
			logger.info("Created model directory: " + modelPath.toString());
			
			// Extract the ZIP file
			extractZipFile(zipBytes, modelPath.toFile());
			
			// Find the actual model directory (it might be nested)
			File actualModelDir = findVoskModelDirectory(modelPath.toFile());
			if (actualModelDir == null) {
				throw new Exception("Could not find valid Vosk model files in the uploaded ZIP");
			}
			
			return actualModelDir.getAbsolutePath();
			
		} catch (Exception e) {
			// Clean up on failure
			try {
				deleteDirectory(modelPath.toFile());
			} catch (Exception cleanupEx) {
				logger.warn("Failed to cleanup temporary directory: " + cleanupEx.getMessage());
			}
			throw e;
		}
	}
	
	/**
	 * Clean up old cache entries to prevent unlimited growth
	 */
	private void cleanupOldCacheEntries() {
		long currentTime = System.currentTimeMillis();
		
		// Only run cleanup occasionally
		if (currentTime % CACHE_CLEANUP_INTERVAL > 1000) {
			return;
		}
		
		logger.info("Running cache cleanup...");
		
		// Find entries older than max age
		for (String hash : cacheAccessTime.keySet()) {
			Long accessTime = cacheAccessTime.get(hash);
			if (accessTime != null && (currentTime - accessTime) > CACHE_MAX_AGE) {
				String cachedPath = modelCache.get(hash);
				if (cachedPath != null) {
					try {
						// Delete the cached directory
						File cachedDir = new File(cachedPath).getParentFile();
						if (cachedDir.getName().startsWith("vosk-model-")) {
							deleteDirectory(cachedDir);
							logger.info("Cleaned up old cached model: " + cachedDir.getAbsolutePath());
						}
					} catch (Exception e) {
						logger.warn("Failed to cleanup old cache entry: " + e.getMessage());
					}
				}
				
				// Remove from cache
				modelCache.remove(hash);
				cacheAccessTime.remove(hash);
			}
		}
		
		logger.info("Cache cleanup completed. Active entries: " + modelCache.size());
	}
	
	/**
	 * Extract ZIP file contents to target directory
	 */
	private void extractZipFile(byte[] zipBytes, File targetDir) throws IOException {
		try (ZipInputStream zipStream = new ZipInputStream(new ByteArrayInputStream(zipBytes))) {
			ZipEntry entry;
			while ((entry = zipStream.getNextEntry()) != null) {
				File entryFile = new File(targetDir, entry.getName());
				
				// Security check - prevent directory traversal
				if (!entryFile.getCanonicalPath().startsWith(targetDir.getCanonicalPath())) {
					throw new IOException("ZIP entry is outside target directory: " + entry.getName());
				}
				
				if (entry.isDirectory()) {
					entryFile.mkdirs();
				} else {
					// Create parent directories if needed
					entryFile.getParentFile().mkdirs();
					
					// Extract file
					try (FileOutputStream fos = new FileOutputStream(entryFile)) {
						byte[] buffer = new byte[1024];
						int length;
						while ((length = zipStream.read(buffer)) > 0) {
							fos.write(buffer, 0, length);
						}
					}
				}
				zipStream.closeEntry();
			}
		}
		logger.info("Successfully extracted ZIP file to: " + targetDir.getAbsolutePath());
	}
	
	/**
	 * Find the directory containing Vosk model files
	 */
	private File findVoskModelDirectory(File rootDir) {
		return findVoskModelDirectoryRecursive(rootDir);
	}
	
	/**
	 * Recursively search for Vosk model directory
	 */
	private File findVoskModelDirectoryRecursive(File dir) {
		// Check if current directory contains Vosk model files
		if (isVoskModelDirectory(dir)) {
			return dir;
		}
		
		// Search subdirectories
		File[] subdirs = dir.listFiles(File::isDirectory);
		if (subdirs != null) {
			for (File subdir : subdirs) {
				File result = findVoskModelDirectoryRecursive(subdir);
				if (result != null) {
					return result;
				}
			}
		}
		
		return null;
	}
	
	/**
	 * Check if directory contains required Vosk model files
	 */
	private boolean isVoskModelDirectory(File dir) {
		if (!dir.isDirectory()) {
			return false;
		}
		
		// Check for essential Vosk model files/directories
		String[] requiredItems = {"am", "graph", "conf"};
		for (String item : requiredItems) {
			File itemFile = new File(dir, item);
			if (!itemFile.exists()) {
				return false;
			}
		}
		
		logger.debug("Found valid Vosk model directory: " + dir.getAbsolutePath());
		return true;
	}
	
	/**
	 * Recursively delete directory and all contents
	 */
	private void deleteDirectory(File dir) throws IOException {
		if (!dir.exists()) {
			return;
		}
		
		if (dir.isDirectory()) {
			File[] files = dir.listFiles();
			if (files != null) {
				for (File file : files) {
					deleteDirectory(file);
				}
			}
		}
		
		if (!dir.delete()) {
			throw new IOException("Failed to delete: " + dir.getAbsolutePath());
		}
	}
	
	/**
	 * Check if the byte array represents a WAV file
	 */
	private boolean isWavFile(byte[] audioBytes) {
		if (audioBytes.length < 12) return false;
		
		String riffHeader = new String(audioBytes, 0, 4);
		String waveHeader = new String(audioBytes, 8, 4);
		
		return "RIFF".equals(riffHeader) && "WAVE".equals(waveHeader);
	}
	
	/**
	 * Validates if the audio file format is supported by Vosk
	 * Vosk works best with WAV files at 16kHz, 16-bit, mono
	 */
	private boolean isValidAudioFormat(String fileName) {
		if (fileName == null) {
			return false;
		}
		String extension = fileName.toLowerCase();
		boolean isValid = extension.endsWith(".wav") || extension.endsWith(".wave");
		if (!isValid) {
			logger.warn("Non-WAV format detected: " + fileName + " - Vosk works best with WAV files");
		}
		return isValid;
	}
	
	/**
	 * Analyzes audio and converts to 16kHz mono if needed
	 */
	private byte[] analyzeAndConvertAudio(byte[] audioBytes, String fileName) {
		if (audioBytes.length < 44) {
			logger.warn("File too small to be valid WAV: " + fileName);
			return audioBytes;
		}
		
		// Check for WAV header and extract format info
		if (isWavFile(audioBytes)) {
			try {
				// Extract key audio parameters
				int sampleRate = ((audioBytes[27] & 0xFF) << 24) | 
								((audioBytes[26] & 0xFF) << 16) | 
								((audioBytes[25] & 0xFF) << 8) | 
								(audioBytes[24] & 0xFF);
				int channels = ((audioBytes[23] & 0xFF) << 8) | (audioBytes[22] & 0xFF);
				int formatCode = ((audioBytes[21] & 0xFF) << 8) | (audioBytes[20] & 0xFF);
				
				logger.info("Audio format: " + sampleRate + "Hz, " + channels + " channels, format code: " + formatCode);
				
				// Check if conversion is needed
				if (formatCode != 1) {
					logger.error("CRITICAL: Audio is not PCM format (code: " + formatCode + ") - Vosk requires PCM");
					return audioBytes;
				} else if (sampleRate != 16000 || channels != 1) {
					logger.info("Converting audio from " + sampleRate + "Hz (" + channels + " ch) to 16kHz mono for optimal Vosk performance");
					return convertAudioTo16kHz(audioBytes, sampleRate, channels);
				} else {
					logger.info("Audio format is already optimal for Vosk transcription");
					return audioBytes;
				}
			} catch (Exception e) {
				logger.warn("Could not analyze WAV format details: " + e.getMessage());
				return audioBytes;
			}
		} else {
			logger.error("Not a WAV file - Vosk works best with WAV format");
			return audioBytes;
		}
	}
	
	/**
	 * Converts audio to 16kHz mono format for optimal Vosk performance
	 */
	private byte[] convertAudioTo16kHz(byte[] audioBytes, int originalSampleRate, int channels) {
		if (originalSampleRate == 16000 && channels == 1) {
			return audioBytes; // Already optimal
		}
		
		try {
			int headerSize = 44; // WAV header size
			int dataSize = audioBytes.length - headerSize;
			
			// Calculate conversion ratio
			double ratio = (double) originalSampleRate / 16000.0;
			int originalSamples = dataSize / (channels * 2); // 16-bit = 2 bytes per sample
			int newSamples = (int) (originalSamples / ratio);
			int newDataSize = newSamples * 2; // mono 16-bit
			
			byte[] converted = new byte[headerSize + newDataSize];
			
			// Copy and modify WAV header
			System.arraycopy(audioBytes, 0, converted, 0, headerSize);
			
			// Update file size (bytes 4-7)
			int newFileSize = headerSize + newDataSize - 8;
			converted[4] = (byte) (newFileSize & 0xFF);
			converted[5] = (byte) ((newFileSize >> 8) & 0xFF);
			converted[6] = (byte) ((newFileSize >> 16) & 0xFF);
			converted[7] = (byte) ((newFileSize >> 24) & 0xFF);
			
			// Update sample rate (bytes 24-27)
			converted[24] = (byte) (16000 & 0xFF);
			converted[25] = (byte) ((16000 >> 8) & 0xFF);
			converted[26] = (byte) ((16000 >> 16) & 0xFF);
			converted[27] = (byte) ((16000 >> 24) & 0xFF);
			
			// Update channels to mono (bytes 22-23)
			converted[22] = 1;
			converted[23] = 0;
			
			// Update byte rate (bytes 28-31): sample_rate * channels * bits_per_sample / 8
			int byteRate = 16000 * 1 * 16 / 8;
			converted[28] = (byte) (byteRate & 0xFF);
			converted[29] = (byte) ((byteRate >> 8) & 0xFF);
			converted[30] = (byte) ((byteRate >> 16) & 0xFF);
			converted[31] = (byte) ((byteRate >> 24) & 0xFF);
			
			// Update block align (bytes 32-33): channels * bits_per_sample / 8
			converted[32] = 2; // 1 channel * 16 bits / 8 = 2
			converted[33] = 0;
			
			// Update data chunk size (bytes 40-43)
			converted[40] = (byte) (newDataSize & 0xFF);
			converted[41] = (byte) ((newDataSize >> 8) & 0xFF);
			converted[42] = (byte) ((newDataSize >> 16) & 0xFF);
			converted[43] = (byte) ((newDataSize >> 24) & 0xFF);
			
			// Convert audio data with downsampling
			for (int i = 0; i < newSamples; i++) {
				int originalIndex = (int) (i * ratio);
				int sourceOffset = headerSize + (originalIndex * channels * 2);
				
				if (sourceOffset + 1 < audioBytes.length) {
					short sample;
					
					if (channels == 2) {
						// Convert stereo to mono by averaging left and right channels
						if (sourceOffset + 3 < audioBytes.length) {
							short leftSample = (short) (((audioBytes[sourceOffset + 1] & 0xFF) << 8) | (audioBytes[sourceOffset] & 0xFF));
							short rightSample = (short) (((audioBytes[sourceOffset + 3] & 0xFF) << 8) | (audioBytes[sourceOffset + 2] & 0xFF));
							sample = (short) ((leftSample + rightSample) / 2);
						} else {
							sample = (short) (((audioBytes[sourceOffset + 1] & 0xFF) << 8) | (audioBytes[sourceOffset] & 0xFF));
						}
					} else {
						// Already mono, just downsample
						sample = (short) (((audioBytes[sourceOffset + 1] & 0xFF) << 8) | (audioBytes[sourceOffset] & 0xFF));
					}
					
					// Write the converted sample
					converted[headerSize + i * 2] = (byte) (sample & 0xFF);
					converted[headerSize + i * 2 + 1] = (byte) ((sample >> 8) & 0xFF);
				}
			}
			
			logger.info("Audio successfully converted from " + originalSampleRate + "Hz (" + channels + " ch) to 16kHz mono for Vosk");
			return converted;
			
		} catch (Exception e) {
			logger.warn("Audio conversion failed, using original: " + e.getMessage());
			return audioBytes;
		}
	}
	// END EXTRA CODE
}
